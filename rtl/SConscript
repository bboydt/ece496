Import("*")

# Expected Imports:
# - env
# - ecp5_soc_dir
# - neorv32_wrapper
# - memory_config: a dictionary with all memory origins and lengths


# Load memory config
#

import json

# Synthesize Design
#

env.Append(
    VPATH = [
        ecp5_soc_dir.Dir("rtl").srcnode(),
    ]
)

top_ast = env.Command(
    "top.json",
    ["top.v", neorv32_wrapper],
    "yosys $YOSYSFLAGS -p \"" +
    " read_verilog $VFLAGS $_VINCFLAGS $_VDEFFLAGS $SOURCES;" +
    " synth_ecp5 -top top -json $TARGET" +
    "\""
)


# Memory Config
#

init_files = {}

memory_json = env.File("memory.json")
# loads the memory json file and emits verilog macros for the address and origin of each memory region
env.Depends(top_ast, memory_json)

memory_config = json.loads(memory_json.get_text_contents())
defines = {}
for addr_range in memory_config:
    
    name = addr_range["name"]
    origin = int(addr_range["origin"], 0)
    length = int(addr_range["length"], 0)
    mask = length - 1
    init = addr_range.get("init", False)
    width = addr_range.get("width", 32)

    defines[f"{name}_ADDR"] = f"\'h{origin:x}"
    defines[f"{name}_LENGTH"] = f"'h{length:x}"
    defines[f"{name}_MASK"] = f"'h{mask:x}"
    
    # if the memory region is initialized create a bram init file
    if (init):
        init_file = env.Command(f"{name}.init", [], f"ecpbram -g $TARGET -w {width} -d {length/width:0.0f}")
        env.Depends(top_ast, init_file)
        
        init_files[name] = init_file
        defines[f"{name}_INIT_FILE"] = f"\\\"{str(init_file[0].abspath)}\\\""


env.Append(VDEFINES = defines)
print("Memory Defines:")
print(defines)


top = {
    "ast": top_ast,
    "init_files": init_files
}

Return("top")
